<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Effects</title>
    <!--cerchiamo un font assurdamente bello-->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Kode+Mono:wght@400..700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
            margin: 0 auto;
            background-color: #f0f0f0;
        }
    </style>
</head>

<body>

    <canvas id="canvas"></canvas>
    <script>
        //crea una costante che prende l'audio dal mic
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();//C:\Progetti\vanilla\VisualFXs\index.html
        let deltaTime = 0;
        class GUIFramework {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                //TUTTO SCHERMO
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.elements = [];
                this.canvas.addEventListener('click', this.handleClick.bind(this));
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                //sfondo grigio figo
                this.ctx.fillStyle = 'black';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                //ordina gli elementi in base al tipo , se il tipo è controller disegnalo sotto  a tutto
                this.elements.sort((a, b) => {
                    if (a.type === 'controller') {
                        return 1;
                    }
                    return -1;
                });
                // Disegna gli elementi controllatori
                this.elements.forEach((element) => {
                    if (element.draw && element.type === 'controller') {
                        element.update();
                        element.draw(this.ctx);
                    }
                });
                // Disegna gli effetti abilitati
                Object.values(mapControllerFX).forEach(controller => {
                    if (controller.enabled && controller.effect.draw) {
                        controller.effect.update();
                        controller.effect.draw();
                    }
                });


            }

            update(deltaTime) {
                this.elements.forEach((element) => {
                    if (element.update) {
                        element.update();
                    }
                });
            }

            handleClick(event) {
                const clickX = event.clientX - this.canvas.offsetLeft;
                const clickY = event.clientY - this.canvas.offsetTop;
                this.elements.forEach((element) => {
                    if (element.isClicked && element.isClicked(clickX, clickY)) {
                        if (audioCtx.state === 'suspended') {
                            audioCtx.resume();
                        }
                        element.onClick();
                    }
                });
            }
        }

        class Button {
            constructor(x, y, width, height, text, onClick) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.text = text;
                this.onClick = onClick;
                this.type = 'controller'
            }

            draw(ctx) {
                ctx.fillStyle = '#555';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#fff';
                ctx.font = '16px Arial';
                ctx.fillText(this.text, this.x + 10, this.y + 25);
            }

            isClicked(clickX, clickY) {
                return clickX >= this.x && clickX <= this.x + this.width &&
                    clickY >= this.y && clickY <= this.y + this.height;
            }

            update() {
                //console.log('update');
            }
        }

        class TextBox {
            constructor(x, y, width, height, value) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.value = '';
                this.type = 'controller'
            }

            draw(ctx) {
                //sfondo bianco
                ctx.fillStyle = 'white';
                ctx.fillRect(this.x, this.y, this.width, this.height);

                ctx.fillStyle = 'black';
                ctx.font = this.height + 'px Arial';
                ctx.fillText(this.value, this.x + 10, this.y + 25);
                ctx.strokeStyle = 'black';
                ctx.strokeRect(this.x, this.y, this.width, this.height);
            }
            update() {
                //console.log('update');
            }
        }

        class Checkbox extends TextBox {
            constructor(x, y, width, height, text, checked) {
                super(x, y, width, height);
                this.text = text;
                this.checked = checked;
            }

            draw(ctx) {
                super.draw(ctx);
                if (this.checked) {
                    ctx.fillStyle = 'black';
                    ctx.fillText('☑', this.x + 5, this.y + 25);
                } else {
                    ctx.fillStyle = 'black';
                    ctx.fillText('☐', this.x + 5, this.y + 25);
                }
                ctx.fillStyle = 'black';
                ctx.fillText(this.text, this.x + 30, this.y + 25);
            }

            onClick() {
                this.checked = !this.checked;
            }

            isClicked(clickX, clickY) {
                return clickX >= this.x && clickX <= this.x + this.width &&
                    clickY >= this.y && clickY <= this.y + this.height;
            }

            update() {
                //console.log('update');
            }
        }

        class Effect {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.enabled = false;
                //bass mid treble
                this.bass = 0;
                this.mid = 0;
                this.treble = 0;
                this.fxType = [];
            }
            draw() {
                throw new Error('draw method must be implemented');
            }
            update() {
                throw new Error('update method must be implemented');
            }
        }

        class TunnelEffect extends Effect {
            constructor(canvasId, numParticles, speed, radius) {
                super(canvasId);
                this.numParticles = numParticles;
                this.speed = speed;
                this.radius = radius;
                this.time = 0;
                this.bass = 0;
                this.mid = 0;
                this.treble = 0;
            }

            update(deltaTime) {
                this.time += this.speed * deltaTime;
            }

            draw() {
                //fai qualcosa di divertente e dinamico conle frequenze
                this.ctx.save();
                //disegna un cerchio al centro del canvas bello grande
                applyEffects(this.ctx, this.fxType.map(type => ({ fxType: type, bass: this.bass, mid: this.mid, treble: this.treble })));

                this.ctx.beginPath();
                this.ctx.arc(this.canvas.width / 2, this.canvas.height / 2, this.radius * 200, 0, Math.PI * 2);
                //stroke line parametrico 
                //fai un colore che dipende dalla frequenza ,non facciamolo tutto nero
                const r = 255 * this.bass / 100;
                const g = 255 * this.mid / 100;
                const b = 255 * this.treble / 100;
                this.ctx.strokeStyle = `rgb(${r},${g},${b})`;
                this.ctx.lineWidth = 5 * this.bass / 2;
                this.ctx.stroke();
                this.ctx.beginPath();
                //disegna una spirale
                this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
                for (let i = 0; i < this.numParticles; i++) {
                    const angle = i * this.numParticles * 2 / this.numParticles;
                    const x = Math.cos(angle) * (this.radius * i);
                    const y = Math.sin(angle) * (this.radius * i);
                    this.ctx.lineTo(x + this.bass, y - this.canvas.height / this.bass);
                }
                this.ctx.strokeStyle = `rgb(${b},${r},${g})`;
                this.ctx.lineWidth = 5 * this.bass / 2;
                this.ctx.stroke();
                this.ctx.restore();

            }

            onmousemove(event) {
                // this.radius = event.clientX;
            }
        }

        class StarRainEffect extends Effect {
            constructor(canvas, numStars, speed) {
                super(canvas);

                //particelle a velocità diverse
                this.numStars = numStars;
                this.speed = speed;
                this.stars = [];
                this.time = 0;
                this.bass = 0;
                this.mid = 0;
                this.treble = 0;
                this.starsSize = 1;

                for (let i = 0; i < this.numStars; i++) {
                    this.stars.push({

                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        speed: Math.random() * 2 + 1,
                        size: Math.random() * 9 + this.starsSize
                    });
                }
            }

            draw() {
                // Draw stars
                this.ctx.save();
                this.stars.forEach(star => {
                    //fillStyle parametrico
                    this.ctx.fillStyle = `rgba(${this.bass},${this.mid},${this.treble},0.5)`;
                    this.ctx.beginPath();
                    this.ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                this.ctx.restore();
            }

            update(deltaTime) {

                this.time += deltaTime;
                this.stars.forEach(star => {
                    //fai una cosa a tempo
                    star.y += star.speed;
                    if (star.y > this.canvas.height) {
                        star.y = 0;
                    }

                });
            }
        }

        class MadDancingShapesEffect extends Effect {
            constructor(canvasId, numSpirals) {
                super(canvasId);
                this.numSpirals = numSpirals;
                this.spirals = [];
                this.time = 0;
                this.bass = 0;
                this.mid = 0;
                this.treble = 0;
                this.initSpirals();
            }

            initSpirals() {
                //POSIZIONA  LE SPIRALI IN PUNTI DIVERSI DEL CANVAS
                for (let i = 0; i < this.numSpirals; i++) {
                    this.spirals.push({
                        angle: 0,
                        angleOffset: Math.random() * Math.PI * 2,
                        radius: Math.random() * 100 + 50,
                        speed: Math.random() * 0.01 + 0.01
                    });
                }
            }

            draw() {
                this.ctx.save();
                this.spirals.forEach(spiral => {
                    this.ctx.beginPath();
                    //LE SPIRALI HANNO ORIGINI DIVERSE
                    this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
                    this.ctx.rotate(spiral.angle + this.mid);
                    this.ctx.moveTo(spiral.radius, this.treble);
                    this.ctx.lineTo(spiral.radius + this.treble, this.bass);
                    const r = 255 * this.bass / 100;
                    const g = 255 * this.mid / 100;
                    const b = 255 * this.treble / 100;
                    this.ctx.strokeStyle = `rgb(${g},${b},${r})`;

                    this.ctx.lineWidth = this.mid;

                    this.ctx.stroke();
                });
                this.ctx.restore();
            }

            update(deltaTime) {
                this.time += deltaTime;
                this.spirals.forEach(spiral => {
                    spiral.angle += spiral.speed / 1000;
                });
            }
        }

        class ScrollingTextEffect extends Effect {
            constructor(canvasId, text, fontSize) {
                super(canvasId);
                this.text = text;
                this.fontSize = fontSize;
                this.x = this.canvas.width;
                this.y = this.canvas.height / 2; // Centrato verticalmente
                this.speed = 2;
            }

            draw() {
                //il colore del testo dipende dalla frequenza
                this.ctx.save();
                const r = 255 * this.bass / 100;
                const g = 255 * this.mid / 100;
                const b = 255 * this.treble / 100;
                this.ctx.fillStyle = `rgb(${b},${g},${r})`;
                //this.ctx.font = `${70 + this.fontSize + this.bass / 32}px Arial`;
                //usa il font figo
                this.ctx.font = `${70 + this.fontSize + this.bass / 32}px 'Kode Mono', monospace`;
                //che font abbiamo ?    
                this.ctx.fillText(this.text, this.x, this.y);

                this.ctx.restore();
            }

            update(deltaTime) {
                this.x -= this.speed;
                if (this.x < -this.ctx.measureText(this.text).width) {
                    this.x = this.canvas.width;
                }
            }
        }

        class ImageEffect extends Effect {
            constructor(canvasId, imageSrc, x,y,width,height) {
                super(canvasId);
                this.image = new Image();
                this.image.src = imageSrc;
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;

                this.image.onload = () => {
                    this.width = this.image.width;
                    this.height = this.image.height;
                };
                this.bass = 0;
                this.mid = 0;
                this.treble = 0;
                //fx type : distort, rotate, scale, translate
            }

            draw() {
                this.ctx.save();
                applyEffects(this.ctx, this.fxType.map(type => ({ fxType: type, bass: this.bass, mid: this.mid, treble: this.treble })));
                this.ctx.drawImage(this.image, this.x, this.y, this.width, this.height);

                this.ctx.restore();
            }

            update() {
                //console.log('update');
            }
        }
        function applyEffects(ctx, effects) {
                    effects.forEach(effect => {
                        switch (effect.fxType) {
                            case 'rotate':
                                ctx.rotate(effect.bass / 100);
                                break;
                            case 'translate':
                                ctx.translate(effect.bass, effect.mid);
                                break;
                            case 'scale':
                                ctx.scale(effect.bass / 100, effect.mid / 100);
                                break;
                            case 'distort':
                                ctx.transform(effect.bass / 1000, effect.mid / 100, effect.treble / 100, effect.bass / 10, effect.mid / 10, effect.treble / 10);
                                break;
                            default:
                                console.error('Unknown effect type:', effect.fxType);
                                break;
                        }
                    });
                }
                
        const gui = new GUIFramework('canvas');
        const buttonsWidth = 130;
        const buttonsHeight = 30;

        const tunnelEffect = new TunnelEffect('canvas', 100, 10, 0.5);
        const checkbox = new Checkbox(20, 10, buttonsWidth, buttonsHeight, ' FX 1', false);

        const starRainEffect = new StarRainEffect('canvas', 100, 0.01);
        const starRainCheckbox = new Checkbox(20, 50, buttonsWidth, buttonsHeight, ' FX 2', false);

        const madDancingShapesEffect = new MadDancingShapesEffect('canvas', 100);
        const madDancingShapesCheckbox = new Checkbox(20, 90, buttonsWidth, buttonsHeight, ' FX 3', false);

        const spiegazione = 'Reality glitches dream electric';
        const scrollingTextEffect = new ScrollingTextEffect('canvas', spiegazione, 32);
        const scrollingTextCheckbox = new Checkbox(20, 130, buttonsWidth, buttonsHeight, ' FX 4', false);

        const imageEffect = new ImageEffect('canvas', 'https://firebasestorage.googleapis.com/v0/b/wada-42dd4.appspot.com/o/images%2Fimageedit_2_5342943839.png?alt=media&token=95e1819b-4c8e-4279-84c4-d47fe9b2bda8',
             500 , 50, 500, 500);
        const imageCheckbox = new Checkbox(20, 170, buttonsWidth, buttonsHeight, ' FX 5', false);

        const buttonGroupTypes = ['rotate', 'translate', 'scale', 'distort'];
        const buttonGroup = [];

        //valorizza i bottoni
        buttonGroupTypes.forEach((type, index) => {
            //Checkbox a finaco del bottone dell'immagine 
            const checkboxes = new Checkbox(buttonsWidth + 20 + index * buttonsWidth + 20, 170 , buttonsWidth, buttonsHeight, type, false);
            checkboxes.onClick = () => {
                imageEffect.fxType = imageEffect.fxType.includes(type) ? imageEffect.fxType.filter(t => t !== type) : [...imageEffect.fxType, type];
                checkboxes.checked = imageEffect.fxType.includes(type);
            };  
            buttonGroup.push(checkboxes);
        });

        const buttonGroupFx1 = [];
        buttonGroupTypes.forEach((type, index) => {
            const checkboxes = new Checkbox(buttonsWidth + 20 + index * buttonsWidth + 20, 10, buttonsWidth, buttonsHeight, type, false);
            checkboxes.onClick = () => {
                tunnelEffect.fxType = tunnelEffect.fxType.includes(type) ? tunnelEffect.fxType.filter(t => t !== type) : [...tunnelEffect.fxType, type];
                checkboxes.checked = tunnelEffect.fxType.includes(type);
            };
            buttonGroupFx1.push(checkboxes);
        });

        const mapControllerFX = {
            'FX 4': {
                effect: scrollingTextEffect,
                checkbox: scrollingTextCheckbox,
                enabled: false,
                params: {}
            },
            'FX 1': {
                effect: tunnelEffect,
                checkbox: checkbox,
                enabled: false,
                params: {}
            },
            'FX 2': {
                effect: starRainEffect,
                checkbox: starRainCheckbox,
                enabled: false,
                params: {}
            },
            'FX 3': {
                effect: madDancingShapesEffect,
                checkbox: madDancingShapesCheckbox,
                enabled: false,
                params: {}
            },
            'FX 5': {
                effect: imageEffect,
                checkbox: imageCheckbox,
                enabled: false,
                params: {}
            }
        };

        function associateCheckboxWithEffect(fxKey) {
            const fx = mapControllerFX[fxKey];
            fx.checkbox.onClick = () => {
                fx.enabled = !fx.enabled;
                fx.effect.enabled = fx.enabled;
                fx.checkbox.checked = fx.enabled;
            };
        }

        Object.keys(mapControllerFX).forEach(associateCheckboxWithEffect);

        checkbox.enabled = true;
        starRainCheckbox.enabled = true;
        madDancingShapesCheckbox.enabled = true;
        scrollingTextCheckbox.enabled = true;
        imageCheckbox.enabled = true;



        gui.elements.push(scrollingTextEffect);
        gui.elements.push(scrollingTextCheckbox);
        gui.elements.push(checkbox);
        gui.elements.push(starRainCheckbox);

        gui.elements.push(starRainEffect);
        gui.elements.push(tunnelEffect);

        gui.elements.push(madDancingShapesEffect);
        gui.elements.push(madDancingShapesCheckbox);

        gui.elements.push(imageEffect);
        gui.elements.push(imageCheckbox);
        buttonGroup.forEach(element => {
            gui.elements.push(element);
        });

        buttonGroupFx1.forEach(element => {
            gui.elements.push(element);
        });

        const analyser = audioCtx.createAnalyser();
        const audioControlButton = new Button(20, 210, buttonsWidth, buttonsHeight, 'Suspend Audio', () => {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => {
                    console.log('Audio resumed.');
                    analyser.connect(audioCtx.destination);
                    audioControlButton.text = 'Suspend Audio';
                }).catch(err => {
                    console.error('Error resuming audio:', err);

                });
            } else {
                audioCtx.suspend().then(() => {
                    console.log('Audio suspended.');
                    audioControlButton.text = 'Resume Audio';

                }).catch(err => {
                    console.error('Error suspending audio:', err);
                });
            }
        });
        gui.elements.push(audioControlButton);

        const stream = navigator.mediaDevices.getUserMedia({ audio: true, video: false });

        stream.then((stream) => {
            const source = audioCtx.createMediaStreamSource(stream);
            source.connect(analyser);
            //analyser.connect(audioCtx.destination);
        });

        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        let lastTime = performance.now();

        animate();

        // Aggiornamento della funzione getMyOutputAnalyser per calcolare separatamente i valori di bassi, medi e alti.
        function getMyOutputAnalyser() {
            const bass = calculateFrequency(dataArray, 20, 250);
            const mid = calculateFrequency(dataArray, 250, 2000);
            const treble = calculateFrequency(dataArray, 2000, 20000);

            return { bass, mid, treble };
        }

        // Funzione ausiliaria per calcolare la frequenza in una specifica banda.
        function calculateFrequency(dataArray, startFreq, endFreq) {
            const startIdx = Math.floor(startFreq / (audioCtx.sampleRate / bufferLength));
            const endIdx = Math.floor(endFreq / (audioCtx.sampleRate / bufferLength));
            const slice = dataArray.slice(startIdx, endIdx);
            return slice.reduce((acc, val) => acc + val, 0) / slice.length;
        }
        // Aggiornamento della funzione animate per aggiornare gli effetti audio durante ogni iterazione.
        let loopAnmationValue = 0;
        function animate() {
            gui.update(deltaTime);
            gui.draw();

            myOutputAnalyser = getMyOutputAnalyser();
            tunnelEffect.speed = myOutputAnalyser.bass / 100;
            tunnelEffect.radius = myOutputAnalyser.mid / 100;
            starRainEffect.speed = myOutputAnalyser.bass / 100;
            starRainEffect.numStars = myOutputAnalyser.treble * 10;
            analyser.getByteFrequencyData(dataArray);
            //disegna lo spettro
            let barWidth = (canvas.width / bufferLength) * 10;
            let barHeight;
            let x = 0;
            let ctx = canvas.getContext('2d');
            for (let i = 0; i < bufferLength; i++) {
                barHeight = dataArray[i];
                //il coloe dipende dalla frequenza
                ctx.fillStyle = 'rgb(' + (barHeight + 100) + ',50,50)';
                ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight / 2);
                x += barWidth + 1;
            }
            deltaTime = performance.now() - lastTime;
            lastTime = performance.now();
            //crea una animazione da paura in base alle frequenze

            function updateAndDrawEffect(effect) {
                if (effect.enabled) {
                    effect.bass = myOutputAnalyser.bass;
                    effect.mid = myOutputAnalyser.mid;
                    effect.treble = myOutputAnalyser.treble;
                    if(effect instanceof StarRainEffect){
                        effect.numStars = myOutputAnalyser.bass * 10;
                        effect.speed = myOutputAnalyser.mid / 100;
                        effect.starsSize = myOutputAnalyser.treble ;
                    }
                    effect.update(deltaTime);
                    effect.draw();
                }
            }

            updateAndDrawEffect(tunnelEffect);
            updateAndDrawEffect(starRainEffect);
            updateAndDrawEffect(madDancingShapesEffect);
            updateAndDrawEffect(scrollingTextEffect);
            updateAndDrawEffect(imageEffect);

            requestAnimationFrame(animate);
        }







    </script>
</body>

</html>